use crate::tokens::{Token, LexicalError};
use crate::ast;

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "program" => Token::KeywordProgram,
    "main" => Token::KeywordMain,
    "print" => Token::KeywordPrint,
    "if" => Token::KeywordIf,
    "else" => Token::KeywordElse,
    "while" => Token::KeywordWhile,
    "do" => Token::KeywordDo,
    "end" => Token::KeywordEnd,
    "int" => Token::KeywordInt,
    "cte_int" => Token::CteInt,
    "float" => Token::KeywordFloat,
    "cte_float" => Token::CteFloat,
    "cte.string" => Token::CteString,
    "var" => Token::KeywordVar,
    "void" => Token::KeywordVoid,
    "id" => Token::Identifier(<String>),
    "integer" => Token::Integer(<i64>),
    "float" => Token::Float(<i64>),
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "=" => Token::AssignSimbol,
    "!=" => Token::NotEqual,
    ">" => Token::BigerThan,
    "<" => Token::SmallerThan,
    ";" => Token::Semicolon,
    "," => Token::Comma,
    "+" => Token::OperatorAdd,
    "-" => Token::OperatorSub,
    "*" => Token::OperatorMul,
    "/" => Token::OperatorDiv,
  }
}

pub Id: String = {
    <s:"id"> => s
};

pub Integer: i64 = {
    <n:"integer"> => n
};

pub Program: Program = {
    "program" <id:Id> ";" <vars:VarsOpt> <funcs:Funcs> "main" <body:Body> "end" => Program {
        id: id,
        vars: vars.unwrap_or(vec![]),
        funcs: funcs,
        body: body,
    }
};

pub VarsOpt: Option<Vec<(String, String)>> = {
    <vars:Vars> => Some(vars),
    () => None
};

pub Funcs: Vec<Function> = {
    <funcs:(<Func> ";")*> => funcs
};

pub Func: Function = {
    "void" <name:Id> "(" <params:IdLoop> ")" <body:Body> => Function {
        id: name,
        params: params,
        vars: vec![],  
        body: body,
    },
    "void" <name:Id> "(" <params:IdLoop> ")" "var" <vars:VarList> <body:Body> => Function {
        id: name,
        params: params,
        vars: vars,
        body: body,
    },
};

pub Vars: Vec<(String, String)> = {
    "var" <vars:VarList> => vars,
    () => vec![]
};

pub VarList: Vec<(String, String)> = {
    <mut v:(<VarDecl> ";")*> => v
};

pub VarDecl: Vec<(String, String)> = {
    <ids:IdList> <t:Type> => {
        ids.into_iter().map(|id| (id, t.clone())).collect::<Vec<(String, String)>>()
    }
};

pub IdList: Vec<Id> = {
  <ids:(<Id> ",")*> => ids
}

pub Type: String = {
    "int" => "int".to_string(),
    "float" => "float".to_string(),
    "void" => "void".to_string()
};

pub Body: Vec<Statement> = {
    "{" <stmts:Statement*> "}" => stmts
};

pub Statement: Statement = {
    <s:Assign> => s,
    <s:Condition> => s,
    <s:Cycle> => s,
    <s:F_Call> => s,
    <s:Print> => s
};

pub Assign: Statement = {
    <id:Id> "=" <e:Expression> ";" => {
      id: id,
      value: Box::new(e),
    }
};

pub Condition: Statement = {
    "if" "(" <e:Expression> ")" <then_body:Body> <else_part:ElsePart> ";" => match else_part {
        Some(else_body) => Statement::Condition {
            condition: Box::new(e),
            then_branch: then_body,
            else_branch: else_body,
        },
        None => Statement::Condition {
            condition: Box::new(e),
            then_branch: then_body,
            else_branch: vec![],
        }
    }
};

pub ElsePart: Option<Vec<Statement>> = {
    "else" <b:Body> => Some(b),
    () => None
};

pub Cycle: Statement = {
  "while" "(" <e:Expression> ")" "do" <b:Body> ";" => Statement::Cycle {
      condition: Box::new(e),
      body: b,
  }
};

pub F_Call: Statement = {
    <id:Id> "(" <args:ExpFCallLoop> ")" ";" => Statement::F_Call {
        id: id,
        args: args,
    }
};

pub ExpFCallLoop: Vec<Expression> = {
    () => vec![],
    <first:Expression> <rest:ExpFCallLoopRest*> => { 
        let mut args = vec![first];
        args.extend(rest);
        args
    }
};

pub ExpFCallLoopRest: Expression = {
    "," <e:Expression> => e
};














pub Print: Statement = {
    "print" "(" <args:ExpStrLoop> ")" ";" => Statement::Print {
        values: args,
    }
};

pub ExpStrLoop: Vec<Expression> = {
    <first:Expression> <rest:CteStringList?> => {
        let mut args = vec![first];
        args.extend(rest.into_iter().flatten());
        args
    }
};

pub CteStringList: Vec<Expression> = {
    "," <s:"cte.string"> => vec![Expression::String(s)],
    "," <s:"cte.string"> <rest:CteStringList> => {
        let mut args = vec![Expression::String(s)];
        args.extend(rest);
        args
    }
};















pub Expression: Expression = {
    <left:Exp> <comp:CompOp?> => match comp {
        Some((op, right)) => Expression::BinaryOperation {
            lhs: Box::new(left),
            operator: op,
            rhs: Box::new(right),
        },
        None => left,
    }
};

pub CompOp: (Operator, Expression) = {
    ">" <right:Exp> => (Operator::Gt, right),
    "<" <right:Exp> => (Operator::Lt, right),
    "!=" <right:Exp> => (Operator::Ne, right)
};

pub Exp: Expression = {
    <term:Term> <loop:ExpLoop> => loop.into_iter().fold(term, |acc, (op, next)| {
        Expression::BinaryOperation {
            lhs: Box::new(acc),
            operator: op,
            rhs: Box::new(next),
        }
    })
};

pub ExpLoop: Vec<(Operator, Expression)> = {
    <ops:(<ExpLoopOp> <Term>)*> => ops.into_iter().collect()
};

pub ExpLoopOp: (Operator, Expression) = {
    "+" <t:Term> => (Operator::Add, t),
    "-" <t:Term> => (Operator::Sub, t)
};

pub Term: Expression = {
    <factor:Factor> <loop:TermLoop> => loop.into_iter().fold(factor, |acc, (op, next)| {
        Expression::BinaryOperation {
            lhs: Box::new(acc),
            operator: op,
            rhs: Box::new(next),
        }
    })
};

pub TermLoop: Vec<(Operator, Expression)> = {
    <ops:(<TermLoopOp> <Factor>)*> => ops.into_iter().collect()
};

pub TermLoopOp: (Operator, Expression) = {
    "*" <f:Factor> => (Operator::Mul, f),
    "/" <f:Factor> => (Operator::Div, f)
};

pub Factor: Expression = {
    "(" <e:Expression> ")" => e,
    <ops:Ops> <idcte:IdCte> => match ops {
        Some(op) => Expression::BinaryOperation {
            lhs: Box::new(match op {
                Operator::Add => Expression::Integer(0),
                Operator::Sub => Expression::Integer(0),
            }),
            operator: op,
            rhs: Box::new(idcte),
        },
        None => idcte,
    }
};

pub Ops: Option<Operator> = {
    "+" => Some(Operator::Add),
    "-" => Some(Operator::Sub),
    () => None
};

pub IdCte: Expression = {
    <id:Id> => Expression::Variable(id),
    <n:Cte> => Expression::Integer(n)
};

pub Cte: i64 = {
    <n:Integer> => n
};

pub IdLoop: Vec<(String, String)> = {
    () => vec![],
    <first:Id> "," <t:Type> <rest:IdLoopRest*> => {
        let mut params = vec![(first, t.clone())];
        params.extend(rest.into_iter().map(|(id, ty)| (id, ty.unwrap_or(t.clone()))));
        params
    }
};

pub IdLoopRest: (String, Option<String>) = {
    "," <id:Id> "," <t:Type> => (id, Some(t)),
    "," <id:Id> => (id, None)
};

pub VarsDesBody: (Vec<(String, String)>, Vec<Statement>) = {
    <vars:Vars> <body:Body> => (vars, body),
    () => (vec![], vec![])
};

