

pub Expression: Expression = {
    
    <exp:Exp> <compop:CompOp?> => Expression => {

    },
    <exp:Exp> SmallerThan <exp:Exp> => Expression,
    <exp:Exp> NotEqual <exp:Exp> => Expression,

};

pub ExprOps: (Operator, Expression) = {
    OperatorAdd <t:Term> => (OperatorAdd, t),
    OperatorSub <t:Term> => (OperatorSub, t)
};

pub Term: Expression = {
    <f:Factor> <ops:TermOps*> => ops.into_iter().fold(f, |acc, (op, factor)| {
        Expression::BinaryOperation {
            lhs: Box::new(acc),
            operator: op,
            rhs: Box::new(factor),
        }
    })
};

pub TermOps: (Operator, Expression) = {
    OperatorMul <f:Factor> => (Operator::Mul, f),
    OperatorDiv <f:Factor> => (Operator::Div, f)
};

pub Factor: Expression = {
    LParen <e:Expression> RParen => e,
    <n:Integer> => Expression::Integer(n),
    <id:Id> => Expression::Variable(id)
};

pub Exp: Expression = {
    Token::LParen <e:Expression> Token::RParen => e,
    <n:Integer> => Expression::Integer(n),
    <id:Id> => Expression::Variable(id)
};




pub IdList: Vec<String> = {
    <first:Id> <rest:CommaIds*> => {
        let mut ids = vec![first];
        for (_, id) in rest {
            ids.push(id);
        }
        ids
    }
};

pub CommaIds: (Token, String) = {
    Comma <id:Id> => (Comma, id)
};

pub Print: Statement = {
    Token::KeywordPrint Token::LParen <e:Expression> Token::RParen Token::Semicolon => Statement::Print {
        value: Box::new(e),
    }
     "cte_string" aún porque no está en los tokens actuales
};

pub Condition: Statement = {
    Token::KeywordIf Token::LParen <cond:Expression> Token::RParen <then:Body> Token::KeywordElse <else_:Body> Token::Semicolon => Statement::Condition {
        condition: Box::new(cond),
        then_branch: then,
        else_branch: else_,
    }
};

pub Cycle: Statement = {
    Token::KeywordWhile Token::LParen <cond:Expression> Token::RParen Token::KeywordDo <body:Body> Token::Semicolon => Statement::Cycle {
        condition: Box::new(cond),
        body: body,
    }
};


pub F_Call: Statement = {
    <id:Id> Token::LParen <e:Expression> Token::RParen Token::Semicolon => Statement::F_Call {
        id: id,
        args: vec![e],
    }
};
pub BinOp: Operator = {
    Token::OperatorAdd => Operator::Add,
    Token::OperatorSub => Operator::Sub,
    Token::OperatorMul => Operator::Mul,
    Token::OperatorDiv => Operator::Div
};

pub Exp: Expression = {
    LParen <e:Expression> RParen => e,
    <n:Integer> => Expression::Integer(n),
    <id:Id> => Expression::Variable(id)
};

pub ExprOps: (Operator, Expression) = {
    Token::OperatorAdd <t:Term> => (Operator::Add, t),
    Token::OperatorSub <t:Term> => (Operator::Sub, t)
};

pub Term: Expression = {
    <f:Factor> <ops:TermOps*> => ops.into_iter().fold(f, |acc, (op, factor)| {
        Expression::BinaryOperation {
            lhs: Box::new(acc),
            operator: op,
            rhs: Box::new(factor),
        }
    })
};

pub TermOps: (Operator, Expression) = {
    Token::OperatorMul <f:Factor> => (Operator::Mul, f),
    Token::OperatorDiv <f:Factor> => (Operator::Div, f)
};

pub Factor: Expression = {
    Token::LParen <e:Expression> Token::RParen => e,
    <n:Integer> => Expression::Integer(n),
    <id:Id> => Expression::Variable(id)
};